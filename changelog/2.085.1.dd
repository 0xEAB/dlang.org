Ddoc

$(CHANGELOG_NAV_INJECT)

$(VERSION Apr 05, 2019, =================================================,

$(CHANGELOG_HEADER_STATISTICS
$(VER) comes with 8 major changes and 0 fixed Bugzilla issues.
                            A huge thanks goes to the 0 contributors who made $(VER) possible.)

$(BUGSTITLE_TEXT_HEADER Compiler changes,

$(LI $(RELATIVE_LINK2 1_deprecation_to_error_visibility,Turn deprecation into error for privately imported symbols inside aggregate declarations))
$(LI $(RELATIVE_LINK2 copy_constructor,Copy Constructor))
$(LI $(RELATIVE_LINK2 dephexstrings,HexString literals are now obsolete))
$(LI $(RELATIVE_LINK2 error_visibility,Turn deprecation into error for selectively imported symbols in imported modules.))
$(LI $(RELATIVE_LINK2 lowmem,New command-line option `-lowmem` to reduce compiler memory requirements))

)

$(BUGSTITLE_TEXT_HEADER Runtime changes,

$(LI $(RELATIVE_LINK2 core_sync_event,New module core.sync.event))

)

$(BUGSTITLE_TEXT_HEADER Library changes,

$(LI $(RELATIVE_LINK2 comparison_bug,Fixed comparison bug in `std.algorithm.comparison.levenshteinDistance`))
$(LI $(RELATIVE_LINK2 std-all,`std.experimental.all` has been moved to `std`))

)

$(CHANGELOG_SEP_HEADER_TEXT_NONEMPTY)

$(CHANGELOG_SEP_HEADER_TEXT)

$(BUGSTITLE_TEXT_BODY Compiler changes,

$(LI $(LNAME2 1_deprecation_to_error_visibility,Turn deprecation into error for privately imported symbols inside aggregate declarations)
$(CHANGELOG_SOURCE_FILE dmd, changelog/1_deprecation_to_error_visibility.dd)
$(P
With this release DMD will issue an error when a symbol that is privately imported in the scope of an aggregate declaration is used as a member of the aggregate outside of the module where the aggregate is defined. Example:
)

---
// a.d
class Foobar
{
    int a;
    this(int a)
    {
        this.a = a;
    }
    static int smeth()
    {
        return 1;
    }
}
void fun() {}

// b.d
struct AST
{
    import a;
}

// c.d
void main()
{
    import b;
    AST.Foobar t;        // triggered a deprecation, but will now trigger an error
    AST.Foobar.smeth();  // error
    AST.fun();           // error
}
---
)

$(LI $(LNAME2 copy_constructor,Copy Constructor)
$(CHANGELOG_SOURCE_FILE dmd, changelog/copy_constructor.dd)
$(P
With this release, the D language compiler implements the full functionality of the
copy constructor described extensively in this DIP [1].
)

$(P
$(P Copy constructors are used to initialize a `struct` instance from
another `struct` of the same type.)
)

$(P
$(P A constructor declaration is a copy constructor declaration if and only if it is a constructor
declaration that takes only one non-default parameter by reference that is
of the same type as `typeof(this)`, followed by any number of default parameters:)
)

---
struct A
{
    this(ref return scope A rhs) {}                        // copy constructor
    this(ref return scope const A rhs, int b = 7) {}       // copy constructor with default parameter
}
---

$(P
$(P The copy constructor is type checked as a normal constructor.)
)

$(P
$(P If a copy constructor is defined, implicit calls to it will be inserted
in the following situations:)
)

$(P
$(OL
$(LI When a variable is explicitly initialized:)
)
---
struct A
{
    this(ref return scope A rhs) {}
}

void main()
{
    A a;
    A b = a; // copy constructor gets called
}
---

$(P
$(LI When a parameter is passed by value to a function:)
)
---
struct A
{
    this(ref return scope A another) {}
}

void fun(A a) {}

void main()
{
    A a;
    fun(a);    // copy constructor gets called
}
---

$(P
$(LI When a parameter is returned by value from a function and Named Returned Value Optiomization (NRVO)
cannot be performed:)
)
---
struct A
{
    this(ref return scope A another) {}
}

A fun()
{
    A a;
    return a;       // NRVO, no copy constructor call
}

A a;
A gun()
{
    return a;       // cannot perform NRVO, rewrite to: return (A __tmp; __tmp.copyCtor(a));
}

void main()
{
    A a = fun();
    A b = gun();
}
---
$(P
)
)

$(P
$(P When a copy constructor is defined for a `struct`, all
implicit blitting is disabled for that `struct`:
)
)
---
struct A
{
    int[] a;
    this(ref return scope A rhs) {}
}

void fun(immutable A) {}

void main()
{
    immutable A a;
    fun(a);          // error: copy constructor cannot be called with types (immutable) immutable
}
---

$(P
$(P The copy constructor can be overloaded with different qualifiers applied
to the parameter (copying from a qualified source) or to the copy constructor
itself (copying to a qualified destination):
)
)
---
struct A
{
    this(ref return scope A another) {}                        // 1 - mutable source, mutable destination
    this(ref return scope immutable A another) {}              // 2 - immutable source, mutable destination
    this(ref return scope A another) immutable {}              // 3 - mutable source, immutable destination
    this(ref return scope immutable A another) immutable {}    // 4 - immutable source, immutable destination
}

void main()
{
    A a;
    immutable A ia;

    A a2 = a;      // calls 1
    A a3 = ia;     // calls 2
    immutable A a4 = a;     // calls 3
    immutable A a5 = ia;    // calls 4
}
---

$(P
$(P The `inout` qualifier may be applied to the copy constructor parameter in
order to specify that mutable, `const`, or `immutable` types are treated the same:
)
)
---
struct A
{
    this(ref return scope inout A rhs) immutable {}
}

void main()
{
    A r1;
    const(A) r2;
    immutable(A) r3;

    // All call the same copy constructor because `inout` acts like a wildcard
    immutable(A) a = r1;
    immutable(A) b = r2;
    immutable(A) c = r3;
}
---

$(P
$(P A copy constructor is generated implicitly by the compiler for a `struct S`
if all of the following conditions are met:)
)

$(P
$(OL
$(LI `S` does not explicitly declare any copy constructors;)
$(LI `S` defines at least one direct member that has a copy constructor, and that
member is not overlapped (by means of `union`) with any other member.)
)
)

$(P
$(P If the restrictions above are met, the following copy constructor is generated:)
)
---
this(ref return scope inout(S) src) inout
{
    foreach (i, ref inout field; src.tupleof)
        this.tupleof[i] = field;
}
---

$(P
$(P If the generated copy constructor fails to type check, it will receive the `@disable` attribute.)
)

$(P
$(P f an `union S` has fields that define a copy constructor, whenever an object of type `S`
is initialized by copy, an error will be issued. The same rule applies to overlapped fields
(anonymous unions).)
)

$(P
$(P A `struct` that defines a copy constructor is not a POD.)
)

$(P
[1] https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1018.md
)
)

$(LI $(LNAME2 dephexstrings,HexString literals are now obsolete)
$(CHANGELOG_SOURCE_FILE dmd, changelog/dephexstrings.dd)
$(P
$(LINK2 http://dlang.org/spec/lex.html#HexString, HexString literals) are obsolete.
)

$(P
Prior to this release, usage of hex string literals would emit a deprecation warning.  Starting with this release they will emit an error.
)

$(P
Use $(LINK2 https://dlang.org/phobos/std_conv.html#hexString, `std.conv.hexString`) instead.
)
)

$(LI $(LNAME2 error_visibility,Turn deprecation into error for selectively imported symbols in imported modules.)
$(CHANGELOG_SOURCE_FILE dmd, changelog/error_visibility.dd)
$(P
With this release DMD will issue an error when a symbol that is privately and selectively imported in `module A` is accessed in `module B` that imports `module A` non-selectively. Example:
)

---
// a.d
import fun : foo;

// b.d
import a;

void main()
{
    foo();     // deprecation up until now; error from now on
}
---

$(P
To make the above code compile, the import in `a.d` needs to be made `public`.
)
)

$(LI $(LNAME2 lowmem,New command-line option `-lowmem` to reduce compiler memory requirements)
$(CHANGELOG_SOURCE_FILE dmd, changelog/lowmem.dd)
$(P
It enables the garbage collector for the compiler, trading compile times for (in some cases, significantly) less memory requirements.
)

$(P
E.g., compiling DMD's test tool d_do_test (`dmd -c [-lowmem] test/tools/d_do_test.d`) requires about 75% less memory (~1,630 MB -> 410) at the cost of a runtime increase by ~30% (~4.8 secs -> 6.3).
)
)


)

$(BUGSTITLE_TEXT_BODY Runtime changes,

$(LI $(LNAME2 core_sync_event,New module core.sync.event)
$(CHANGELOG_SOURCE_FILE druntime, changelog/core_sync_event.dd)
$(P
This module provides a cross-platform interface for lightweight signaling of other threads.
It can be used to start execution of multiple waiting threads simultaneously.
)
)


)

$(BUGSTITLE_TEXT_BODY Library changes,

$(LI $(LNAME2 comparison_bug,Fixed comparison bug in `std.algorithm.comparison.levenshteinDistance`)
$(CHANGELOG_SOURCE_FILE phobos, changelog/comparison_bug.dd)
$(P
Previously the algorithm was allocating the amount of memory which was equal to
the size of the biggest range, that is $(BIGOH max(s.length, t.length)).
This is now fixed to be $(BIGOH min(s.length, t.length)).
For more details see $(REF levenshteinDistance, std, algorithm, comparison).
)
)

$(LI $(LNAME2 std-all,`std.experimental.all` has been moved to `std`)
$(CHANGELOG_SOURCE_FILE phobos, changelog/std-all.dd)
$(P
`std.experimental.all` allowed the convenient use of all Phobos modules
with one import (`import std.experimental.all;`). With this release, this
convenience module has been stabilized and moved to `std`. From now on, the
convenience module can be accessed with `import std;`:
)

---
import std;
void main()
{
    5f.iota.map!exp2.sum; // 31
}
---

$(P
Scripts and experimental code often use long and frequently changing
lists of imports from the standard library.
)

$(P
With this release it is possible to use `import std;` for importing the entire
standard library at once. This can be used for fast prototyping or REPLs:
)

---
import std;
void main()
{
    6.iota
      .filter!(a => a % 2) // 1 3 5
      .map!(a => a * 2) // 2 6 10
      .tee!writeln // peek into the processed stream
      .substitute(6, -6) // 2 -6 10
      .mean // (2 - 6 + 10) / 3
      .reverseArgs!writefln("Sum: %.2f"); // 2
}
---

$(P
As before, symbol conflicts will only arise if a symbol with collisions is used.
In this case, $(LINK2 $(ROOT)spec/module.html#static_imports, static imports) or
$(LINK2 $(ROOT)spec/module.html#renamed_imports, renamed imports) can be used
to uniquely select a specific symbol.
)

$(P
The baseline cost for `import std;`
is less than half a second (varying from system to system) and
work is in progress to reduce this overhead even further.
)
)


)

$(CHANGELOG_SEP_TEXT_BUGZILLA)

)
$(D_CONTRIBUTORS_HEADER 0)
$(D_CONTRIBUTORS
)
$(D_CONTRIBUTORS_FOOTER)
$(CHANGELOG_NAV_INJECT)

Macros:
    VER=2.085.1
    TITLE=Change Log: $(VER)
